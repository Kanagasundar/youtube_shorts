name: YouTube Automation

on:
  schedule:
    - cron: '0 9 * * *'  # Daily at 9:00 AM UTC
  workflow_dispatch:
    inputs:
      topic_override:
        description: 'Override today''s topic (optional)'
        required: false
        type: string
      category_override:
        description: 'Override category (optional)'
        required: false
        type: string

jobs:
  create-and-upload-video:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg espeak espeak-data libespeak1 libespeak-dev
          sudo apt-get install -y python3-dev python3-pip python3-venv
          sudo apt-get install -y libffi-dev libssl-dev libxml2-dev libxslt1-dev
          sudo apt-get install -y build-essential libasound2-dev portaudio19-dev
          sudo apt-get install -y jq
          sudo apt-get install -y libavcodec-dev libavformat-dev libavdevice-dev
          sudo apt-get install -y libavfilter-dev libswscale-dev libswresample-dev
          ffmpeg -version
          echo "‚úÖ System dependencies installed"

      - name: Verify system dependencies
        run: |
          echo "üîç Verifying system dependencies..."
          ffmpeg -version || { echo "‚ùå FFmpeg not installed correctly"; exit 1; }
          echo "‚úÖ FFmpeg verified"

      - name: Check disk space
        run: |
          echo "üîç Checking available disk space..."
          df -h
          echo "‚úÖ Disk space check completed"

      - name: Install Python dependencies
        run: |
          echo "üì¶ Installing Python dependencies..."
          python -m pip cache purge
          python -m pip install --upgrade pip==24.2 setuptools==70.3.0 wheel==0.43.0
          pip install --no-cache-dir --force-reinstall numpy==1.26.4
          pip install --no-cache-dir -r requirements.txt
          pip install --no-cache-dir --force-reinstall moviepy==1.0.2 openai==1.40.6
          pip list
          echo "‚úÖ All dependencies installed successfully"

      - name: Check for proxies references
        run: |
          echo "üîç Checking for 'proxies' in Python files..."
          git grep -i "proxies" *.py utils/*.py || echo "No 'proxies' references found"
          echo "‚úÖ Proxies check completed"

      - name: Log script contents for debugging
        run: |
          echo "üîç Logging contents of main.py and utils/scripting.py..."
          echo "üìÑ main.py:"
          cat main.py || echo "‚ùå main.py not found"
          echo "üìÑ utils/scripting.py:"
          cat utils/scripting.py || echo "‚ùå utils/scripting.py not found"
          echo "‚úÖ Script contents logged"

      - name: Verify Python dependencies
        run: |
          echo "üîß Verifying Python dependencies..."
          python -c "
          import sys
          packages = ['numpy', 'PIL.Image', 'openai', 'gtts', 'pydub', 'requests', 'moviepy.editor', 'google.auth']
          for pkg in packages:
              try:
                  __import__(pkg)
                  print(f'‚úÖ {pkg}: Import successful')
              except Exception as e:
                  print(f'‚ùå {pkg}: {str(e)}')
                  sys.exit(1)
          print('‚úÖ All critical packages verified successfully')
          "

      - name: Clear Python module cache
        run: |
          echo "üßπ Clearing Python module cache..."
          find . -name "*.pyc" -delete
          find . -name "__pycache__" -type d -exec rm -rf {} +
          echo "‚úÖ Module cache cleared"

      - name: Create output directories
        run: |
          mkdir -p output
          mkdir -p logs
          echo "‚úÖ Output directories created"

      - name: Set up YouTube credentials
        env:
          YOUTUBE_CREDENTIALS: ${{ secrets.YOUTUBE_CREDENTIALS }}
          YOUTUBE_TOKEN: ${{ secrets.YOUTUBE_TOKEN }}
        run: |
          echo "üîç Setting up YouTube credentials..."
          if [ -n "$YOUTUBE_CREDENTIALS" ]; then
            echo "$YOUTUBE_CREDENTIALS" > credentials.json
            echo "‚úÖ YOUTUBE_CREDENTIALS set"
          else
            echo "‚ùå YOUTUBE_CREDENTIALS not set"
            echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
            exit 1
          fi
          if [ -f credentials.json ] && jq empty credentials.json > /dev/null 2>&1; then
            echo "‚úÖ credentials.json is valid JSON"
            echo "YOUTUBE_CREDENTIALS_VALID=true" >> $GITHUB_ENV
          else
            echo "‚ùå credentials.json is invalid or missing"
            echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
            exit 1
          fi
          if [ -n "$YOUTUBE_TOKEN" ]; then
            echo "$YOUTUBE_TOKEN" | base64 -d > token.pickle 2>/dev/null
            if [ -s token.pickle ]; then
              echo "‚úÖ YouTube token restored"
            else
              echo "‚ö†Ô∏è YouTube token restoration failed"
            fi
          fi
          echo "‚úÖ YouTube credentials setup completed"

      - name: Set upload status
        run: |
          echo "üîß Determining upload status..."
          if [ "${{ env.YOUTUBE_CREDENTIALS_VALID }}" = "true" ] && [ "${{ vars.ENABLE_UPLOAD || 'true' }}" = "true" ]; then
            echo "‚úÖ Upload enabled"
            echo "UPLOAD_TO_YOUTUBE=true" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Upload disabled"
            echo "UPLOAD_TO_YOUTUBE=false" >> $GITHUB_ENV
          fi

      - name: Create environment file
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          VIDEO_PRIVACY: ${{ vars.VIDEO_PRIVACY || 'public' }}
          VIDEO_CATEGORY_ID: ${{ vars.VIDEO_CATEGORY_ID || '28' }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          echo "üîç Checking environment variables..."
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "‚ùå OPENAI_API_KEY is not set in repository secrets"
            echo "üí° Please add OPENAI_API_KEY to GitHub Actions secrets at https://github.com/Kanagasundar/youtube_shorts/settings/secrets/actions"
            exit 1
          else
            echo "‚úÖ OPENAI_API_KEY is set"
          fi
          cat > .env << EOF
          OPENAI_API_KEY=$OPENAI_API_KEY
          VIDEO_PRIVACY=$VIDEO_PRIVACY
          VIDEO_CATEGORY_ID=$VIDEO_CATEGORY_ID
          UPLOAD_TO_YOUTUBE=${{ env.UPLOAD_TO_YOUTUBE }}
          MAX_RETRIES=5
          DISCORD_WEBHOOK_URL=$DISCORD_WEBHOOK_URL
          EOF
          if [ -n "${{ github.event.inputs.topic_override }}" ]; then
            echo "TOPIC_OVERRIDE=${{ github.event.inputs.topic_override }}" >> .env
          fi
          if [ -n "${{ github.event.inputs.category_override }}" ]; then
            echo "CATEGORY_OVERRIDE=${{ github.event.inputs.category_override }}" >> .env
          fi
          echo "‚úÖ Environment file created"

      - name: Run YouTube automation
        id: automation
        env:
          PYTHONUNBUFFERED: "1"
          PYTHONPATH: "${{ github.workspace }}:${{ github.workspace }}/utils"
          PYTHONDONTWRITEBYTECODE: "1"
          PYTHONIOENCODING: "utf-8"
        run: |
          echo "üöÄ Starting YouTube automation..."
          unset HTTP_PROXY HTTPS_PROXY NO_PROXY
          python -c "import os; print('Environment variables:', {k: '***' if 'KEY' in k or 'TOKEN' in k else v for k, v in sorted(os.environ.items())})"
          python main.py 2>&1 | tee automation.log
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Automation failed with exit code $EXIT_CODE"
            tail -20 automation.log
            exit $EXIT_CODE
          fi
          echo "‚úÖ Automation completed successfully"

      - name: Debug environment on failure
        if: failure()
        run: |
          echo "üîç Debugging environment..."
          pip list
          python -m site
          echo "‚úÖ Environment debug info collected"

      - name: Save updated YouTube token
        if: always() && env.YOUTUBE_CREDENTIALS_VALID == 'true'
        id: save_token
        run: |
          if [ -f token.pickle ]; then
            base64 token.pickle > token_updated.txt
            echo "token_content=$(cat token_updated.txt)" >> $GITHUB_OUTPUT
            echo "‚úÖ Updated token prepared"
          else
            echo "‚ÑπÔ∏è No token.pickle found"
          fi

      - name: Upload artifacts on failure or partial success
        if: failure() || steps.automation.outputs.exit_code == '2'
        uses: actions/upload-artifact@v4
        with:
          name: automation-failure-logs-${{ github.run_number }}
          path: |
            automation.log
            output/
            logs/
            *.json
            *.txt
            *.env
          retention-days: 7

      - name: Upload successful artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: automation-success-${{ github.run_number }}
          path: |
            output/
            logs/
            automation.log
          retention-days: 3

      - name: Extract video information
        if: success()
        id: video_info
        run: |
          VIDEO_TITLE=$(grep -E "^‚úÖ Topic:" automation.log | head -1 | cut -d' ' -f3- || echo "Unknown")
          VIDEO_ID=$(grep "Video uploaded with ID:" automation.log | tail -1 | awk '{print $NF}' || echo "")
          VIDEO_CATEGORY=$(grep -E "^‚úÖ Category:" automation.log | head -1 | cut -d' ' -f3- || echo "Unknown")
          VIDEO_TITLE=$(echo "$VIDEO_TITLE" | sed 's/[^a-zA-Z0-9 .,!?-]//g' | head -c 100)
          VIDEO_ID=$(echo "$VIDEO_ID" | grep -E '^[a-zA-Z0-9_-]{11}$' || echo "")
          echo "video_title=$VIDEO_TITLE" >> $GITHUB_OUTPUT
          echo "video_id=$VIDEO_ID" >> $GITHUB_OUTPUT
          echo "video_category=$VIDEO_CATEGORY" >> $GITHUB_OUTPUT

      - name: Send success notification
        if: success() && env.DISCORD_WEBHOOK_URL
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          VIDEO_TITLE="${{ steps.video_info.outputs.video_title }}"
          VIDEO_ID="${{ steps.video_info.outputs.video_id }}"
          VIDEO_CATEGORY="${{ steps.video_info.outputs.video_category }}"
          UPLOAD_STATUS="${{ env.UPLOAD_TO_YOUTUBE == 'true' && 'Uploaded' || 'Generated (Upload Disabled)' }}"
          PAYLOAD=$(cat << EOF
          {
            "embeds": [{
              "title": "‚úÖ YouTube Video Published Successfully!",
              "description": "**Title:** ${VIDEO_TITLE}\n**Category:** ${VIDEO_CATEGORY}\n**Video ID:** ${VIDEO_ID}\n**URL:** https://www.youtube.com/watch?v=${VIDEO_ID}",
              "color": 5763719,
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
              "footer": { "text": "YouTube Automation ‚Ä¢ Run #${{ github.run_number }}" }
            }]
          }
          EOF
          )
          curl -H "Content-Type: application/json" -X POST -d "$PAYLOAD" "$DISCORD_WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send Discord notification"

      - name: Send failure notification
        if: failure() && env.DISCORD_WEBHOOK_URL
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          ERROR_MSG=$(tail -10 automation.log | tr '\n' ' ' | sed 's/"/\\"/g' | head -c 400 || echo "Unknown error")
          PAYLOAD=$(cat << EOF
          {
            "embeds": [{
              "title": "‚ùå YouTube Automation Failed",
              "description": "**Error:** ${ERROR_MSG}\n**Run:** #${{ github.run_number }}",
              "color": 15158332,
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
              "footer": { "text": "Check the Actions tab for logs" }
            }]
          }
          EOF
          )
          curl -H "Content-Type: application/json" -X POST -d "$PAYLOAD" "$DISCORD_WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send Discord failure notification"

  cleanup:
    runs-on: ubuntu-latest
    needs: create-and-upload-video
    if: always()

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cleanup old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            try {
              console.log('üßπ Starting artifact cleanup...')
              const { data: artifacts } = await github.rest.actions.listArtifactsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              })
              console.log(`Found ${artifacts.artifacts.length} artifacts`)
              const oldArtifacts = artifacts.artifacts
                .filter(artifact => artifact.name.includes('automation-'))
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .slice(10)
              console.log(`Found ${oldArtifacts.length} old artifacts to delete`)
              let deletedCount = 0
              for (const artifact of oldArtifacts) {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                })
                console.log(`‚úÖ Deleted artifact: ${artifact.name} (ID: ${artifact.id})`)
                deletedCount++
                await new Promise(resolve => setTimeout(resolve, 100))
              }
              console.log(`‚úÖ Cleanup completed: ${deletedCount} deleted`)
            } catch (error) {
              console.error('‚ùå Artifact cleanup failed:', error.message)
            }

      - name: Cleanup old workflow runs
        uses: actions/github-script@v7
        with:
          script: |
            try {
              console.log('üßπ Starting workflow run cleanup...')
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
                status: 'completed'
              })
              console.log(`Found ${runs.workflow_runs.length} completed workflow runs`)
              const oldRuns = runs.workflow_runs
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .slice(20)
              console.log(`Found ${oldRuns.length} old workflow runs to delete`)
              let deletedCount = 0
              for (const run of oldRuns) {
                const runDate = new Date(run.created_at)
                const thirtyDaysAgo = new Date()
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
                if (runDate < thirtyDaysAgo) {
                  await github.rest.actions.deleteWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id
                  })
                  console.log(`‚úÖ Deleted workflow run: #${run.run_number}`)
                  deletedCount++
                  await new Promise(resolve => setTimeout(resolve, 200))
                }
              }
              console.log(`‚úÖ Workflow cleanup completed: ${deletedCount} deleted`)
            } catch (error) {
              console.error('‚ùå Workflow run cleanup failed:', error.message)
            }

      - name: Report cleanup summary
        uses: actions/github-script@v7
        with:
          script: |
            await core.summary
              .addRaw(`
                ## üßπ Cleanup Summary
                - **Artifacts**: Cleaned up old automation artifacts (keeping 10 most recent)
                - **Workflow Runs**: Cleaned up runs older than 30 days (keeping 20 most recent)
                - **Status**: Maintenance completed
              `)
              .write()