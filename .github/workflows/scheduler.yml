name: YouTube Automation

on:
  schedule:
    # Run daily at 9:00 AM UTC (adjust as needed)
    - cron: '0 9 * * *'
  workflow_dispatch:
    # Allow manual triggering
    inputs:
      topic_override:
        description: 'Override today''s topic (optional)'
        required: false
        type: string
      category_override:
        description: 'Override category (optional)'
        required: false  
        type: string

jobs:
  create-and-upload-video:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg espeak espeak-data libespeak1 libespeak-dev
        ffmpeg -version  # Verify ffmpeg installation
        echo "ffmpeg version check completed"
      continue-on-error: false
      
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install --no-cache-dir -r requirements.txt  # Force fresh install without cache
        pip install --no-cache-dir imageio_ffmpeg>=0.4.0  # Explicitly install imageio_ffmpeg
        pip show moviepy  # Verify moviepy installation
        echo "Installed moviepy version details:"
        pip show moviepy || echo "moviepy not found"
        python -c "import moviepy.editor as mp; print('moviepy.editor version:', mp.__version__)" || {
          echo "Error: moviepy.editor import failed with version 2.2.1";
          pip install --no-cache-dir moviepy==1.0.3;
          python -c "import moviepy.editor as mp; print('moviepy.editor version (fallback):', mp.__version__)" || {
            echo "Error: moviepy.editor import failed even with fallback version 1.0.3";
            exit 1;
          }
        }
        echo "Dependency installation and verification completed"
      continue-on-error: false
      
    - name: Create output directory
      run: mkdir -p output
      
    - name: Set up YouTube credentials
      env:
        YOUTUBE_CREDENTIALS: ${{ secrets.YOUTUBE_CREDENTIALS }}
        YOUTUBE_TOKEN: ${{ secrets.YOUTUBE_TOKEN }}
      run: |
        echo "$YOUTUBE_CREDENTIALS" > credentials.json
        if [ ! -z "$YOUTUBE_TOKEN" ]; then
          echo "$YOUTUBE_TOKEN" | base64 -d > token.pickle
        fi
        
    - name: Create environment file
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        VIDEO_PRIVACY: ${{ vars.VIDEO_PRIVACY || 'public' }}
        VIDEO_CATEGORY_ID: ${{ vars.VIDEO_CATEGORY_ID || '28' }}
        ENABLE_UPLOAD: ${{ vars.ENABLE_UPLOAD || 'true' }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        cat << EOF > .env
        OPENAI_API_KEY=$OPENAI_API_KEY
        VIDEO_PRIVACY=$VIDEO_PRIVACY
        VIDEO_CATEGORY_ID=$VIDEO_CATEGORY_ID
        ENABLE_UPLOAD=$ENABLE_UPLOAD
        DISCORD_WEBHOOK_URL=$DISCORD_WEBHOOK_URL
        EOF
        
    - name: Run YouTube automation
      id: automation
      env:
        TOPIC_OVERRIDE: ${{ github.event.inputs.topic_override }}
        CATEGORY_OVERRIDE: ${{ github.event.inputs.category_override }}
      run: |
        if [ ! -z "$TOPIC_OVERRIDE" ]; then
          echo "TOPIC_OVERRIDE=$TOPIC_OVERRIDE" >> .env
        fi
        if [ ! -z "$CATEGORY_OVERRIDE" ]; then
          echo "CATEGORY_OVERRIDE=$CATEGORY_OVERRIDE" >> .env
        fi
        
        python main.py 2>&1 | tee automation.log
        echo "exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT
        
    - name: Save updated token
      if: always()
      run: |
        if [ -f token.pickle ]; then
          base64 -w 0 token.pickle > token_updated.txt
          echo "Updated token available for storage"
        fi
        
    - name: Upload artifacts on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: automation-logs-${{ github.run_number }}
        path: |
          automation.log
          output/
        retention-days: 7
        
    - name: Send success notification
      if: success() && env.DISCORD_WEBHOOK_URL != ''
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        VIDEO_TITLE=$(grep "Topic:" automation.log | head -1 | cut -d' ' -f3-)
        VIDEO_ID=$(grep "Video uploaded with ID:" automation.log | tail -1 | awk '{print $NF}')
        
        if [ ! -z "$VIDEO_ID" ]; then
          curl -H "Content-Type: application/json" \
               -X POST \
               -d "{
                 \"embeds\": [{
                   \"title\": \"✅ YouTube Video Published Successfully!\",
                   \"description\": \"**Title:** $VIDEO_TITLE\\n**Video ID:** $VIDEO_ID\\n**URL:** https://www.youtube.com/watch?v=$VIDEO_ID\",
                   \"color\": 5763719,
                   \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"
                 }]
               }" \
               $DISCORD_WEBHOOK_URL
        fi
        
    - name: Send failure notification  
      if: failure() && env.DISCORD_WEBHOOK_URL != ''
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        ERROR_MSG=$(tail -10 automation.log | tr '\n' ' ')
        curl -H "Content-Type: application/json" \
             -X POST \
             -d "{
               \"embeds\": [{
                 \"title\": \"❌ YouTube Automation Failed\",
                 \"description\": \"**Error:** $ERROR_MSG\\n**Run:** ${{ github.run_number }}\\n**Workflow:** ${{ github.workflow }}\",
                 \"color\": 15158332,
                 \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"
               }]
             }" \
             $DISCORD_WEBHOOK_URL

  cleanup:
    runs-on: ubuntu-latest
    needs: create-and-upload-video
    if: always()
    
    steps:
    - name: Cleanup old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: context.runId
          });
          
          // Keep only the 5 most recent artifacts
          const oldArtifacts = artifacts.data.artifacts
            .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
            .slice(5);
            
          for (const artifact of oldArtifacts) {
            await github.rest.actions.deleteArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: artifact.id
            });
          }