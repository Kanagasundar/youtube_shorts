name: YouTube Automation

on:
  schedule:
    - cron: '0 9 * * *'  # Daily at 9:00 AM UTC
  workflow_dispatch:
    inputs:
      topic_override:
        description: 'Override today''s topic (optional)'
        required: false
        type: string
      category_override:
        description: 'Override category (optional)'
        required: false
        type: string

jobs:
  create-and-upload-video:
    runs-on: ubuntu-latest
    timeout-minutes: 45  # Increased timeout for video processing

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg espeak espeak-data libespeak1 libespeak-dev
        sudo apt-get install -y python3-dev python3-pip python3-venv
        sudo apt-get install -y libffi-dev libssl-dev libxml2-dev libxslt-dev
        sudo apt-get install -y build-essential libasound2-dev portaudio19-dev
        sudo apt-get install -y jq
        # Additional dependencies for video processing
        sudo apt-get install -y libavcodec-dev libavformat-dev libavdevice-dev
        sudo apt-get install -y libavfilter-dev libswscale-dev libswresample-dev
        # Verify ffmpeg installation
        ffmpeg -version
        echo "‚úÖ System dependencies installed"

    - name: Upgrade pip and setuptools
      run: |
        python -m pip install --upgrade pip setuptools wheel
        echo "‚úÖ Pip upgraded to $(pip --version)"

    - name: Install Python dependencies with retry logic
      run: |
        echo "üì¶ Installing Python dependencies..."
        
        # Function to install package with retries
        install_with_retry() {
          local package=$1
          local max_attempts=3
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt: Installing $package"
            if python -m pip install --no-cache-dir "$package"; then
              echo "‚úÖ Successfully installed $package"
              return 0
            else
              echo "‚ùå Failed to install $package (attempt $attempt)"
              attempt=$((attempt + 1))
              if [ $attempt -le $max_attempts ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
              fi
            fi
          done
          
          echo "‚ùå Failed to install $package after $max_attempts attempts"
          return 1
        }
        
        # Install critical dependencies first in specific order
        echo "üîß Installing critical dependencies first..."
        
        # Base dependencies
        install_with_retry "setuptools>=65.0.0,<70.0.0"
        install_with_retry "wheel>=0.37.0,<1.0.0"
        install_with_retry "six>=1.16.0,<2.0.0"
        install_with_retry "certifi>=2022.12.7"
        install_with_retry "requests>=2.28.0,<3.0.0"
        install_with_retry "numpy>=1.21.0,<2.0.0"
        
        # Google Auth dependencies in order
        echo "üîß Installing Google Auth dependencies..."
        install_with_retry "cachetools>=4.0.0,<6.0.0"
        install_with_retry "pyasn1>=0.4.6,<0.6.0"
        install_with_retry "pyasn1-modules>=0.2.1,<0.4.0"
        install_with_retry "rsa>=3.1.4,<5.0.0"
        install_with_retry "google-auth>=2.0.0,<3.0.0"
        install_with_retry "google-auth-oauthlib>=0.5.0,<2.0.0"
        install_with_retry "google-api-python-client>=2.0.0,<3.0.0"
        
        # Video processing dependencies
        echo "üîß Installing video processing dependencies..."
        install_with_retry "Pillow>=9.0.0,<10.0.0"
        install_with_retry "imageio>=2.25.0,<3.0.0"
        install_with_retry "imageio-ffmpeg>=0.4.8,<1.0.0"
        install_with_retry "decorator>=4.4.0,<6.0.0"
        install_with_retry "proglog>=0.1.10,<1.0.0"
        install_with_retry "tqdm>=4.62.0,<5.0.0"
        
        # MoviePy - often problematic, install separately
        echo "üîß Installing MoviePy..."
        install_with_retry "moviepy>=1.0.3,<2.0.0"
        
        # Audio processing
        echo "üîß Installing audio dependencies..."
        install_with_retry "gTTS>=2.3.0,<3.0.0"
        install_with_retry "pydub>=0.25.1,<1.0.0"
        
        # OpenAI
        echo "üîß Installing OpenAI..."
        install_with_retry "openai>=1.0.0,<2.0.0"
        
        # Install remaining requirements
        echo "üîß Installing remaining requirements..."
        python -m pip install --no-cache-dir -r requirements.txt || echo "‚ö†Ô∏è Some packages from requirements.txt may have failed"
        
        echo "‚úÖ All critical dependencies installation completed"

    - name: Verify critical installations with detailed debugging
      run: |
        echo "üîç Verifying critical package installations..."
        python -c "
        import sys
        import importlib
        import pkg_resources
        
        print('üêç Python version:', sys.version)
        print('üì¶ Installed packages:')
        for pkg in pkg_resources.working_set:
            print(f'   - {pkg.project_name}: {pkg.version}')
        
        print('\nüîç Testing specific imports:')
        
        # Test packages individually for better error handling
        packages_to_test = [
            ('numpy', 'import numpy; print(f\"‚úÖ numpy: {numpy.__version__}\")'),
            ('Pillow', 'import PIL; print(f\"‚úÖ Pillow: {PIL.__version__}\")'),
            ('openai', 'import openai; print(f\"‚úÖ openai: {openai.__version__}\")'),
            ('gTTS', 'import gtts; print(f\"‚úÖ gTTS: {gtts.__version__}\")'),
            ('pydub', 'import pydub; print(f\"‚úÖ pydub: available\")'),
            ('moviepy.editor', 'import moviepy.editor; print(f\"‚úÖ moviepy.editor: {moviepy.__version__}\")', 'moviepy'),
            ('google.auth', 'import google.auth; print(f\"‚úÖ google.auth: {google.auth.__version__}\")', 'google-auth'),
            ('google_auth_oauthlib', 'import google_auth_oauthlib; print(\"‚úÖ google-auth-oauthlib: available\")'),
            ('googleapiclient', 'import googleapiclient; print(\"‚úÖ google-api-python-client: available\")'),
            ('requests', 'import requests; print(f\"‚úÖ requests: {requests.__version__}\")')
        ]
        
        failed_packages = []
        
        for item in packages_to_test:
            if len(item) == 3:
                package_name, test_code, display_name = item
            else:
                package_name, test_code = item
                display_name = package_name
                
            try:
                exec(test_code)
            except Exception as e:
                print(f'‚ùå {display_name}: {e}')
                failed_packages.append(display_name)
                
                # Additional debugging for specific packages
                if 'moviepy' in package_name:
                    try:
                        import moviepy
                        print(f'   üìã moviepy module found at: {moviepy.__file__}')
                        print(f'   üìã moviepy attributes: {dir(moviepy)[:10]}...')
                    except:
                        print('   üìã moviepy module not found at all')
                
                if 'google.auth' in package_name:
                    try:
                        import google
                        print(f'   üìã google module found at: {google.__file__}')
                        print(f'   üìã google attributes: {dir(google)[:10]}...')
                    except:
                        print('   üìã google module not found at all')
        
        if failed_packages:
            print(f'\\n‚ùå Failed packages: {failed_packages}')
            print('\\nüîß Attempting to fix failed packages...')
            
            # Try alternative installations for common failures
            if 'moviepy' in failed_packages:
                print('üîß Attempting alternative moviepy installation...')
                import subprocess
                subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'moviepy'])
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', '--force-reinstall', 'moviepy==1.0.3'])
            
            if 'google-auth' in failed_packages:
                print('üîß Attempting alternative google-auth installation...')
                import subprocess
                subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'google-auth'])
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', '--force-reinstall', 'google-auth>=2.0.0'])
            
            # Re-test after fixes
            print('\\nüîç Re-testing after fixes...')
            remaining_failures = []
            for item in packages_to_test:
                if len(item) == 3:
                    package_name, test_code, display_name = item
                else:
                    package_name, test_code = item
                    display_name = package_name
                    
                if display_name in failed_packages:
                    try:
                        exec(test_code)
                        print(f'‚úÖ {display_name}: Fixed!')
                    except Exception as e:
                        print(f'‚ùå {display_name}: Still failing - {e}')
                        remaining_failures.append(display_name)
            
            if remaining_failures:
                print(f'\\n‚ùå Packages still failing after fixes: {remaining_failures}')
                print('‚ö†Ô∏è Continuing with available packages...')
            else:
                print('\\n‚úÖ All packages fixed successfully!')
        else:
            print('\\n‚úÖ All critical packages verified successfully')
        "

    - name: Create output directories
      run: |
        mkdir -p output
        mkdir -p logs
        echo "‚úÖ Output directories created"

    - name: Set up YouTube credentials
      env:
        YOUTUBE_CREDENTIALS: ${{ secrets.YOUTUBE_CREDENTIALS }}
        YOUTUBE_TOKEN: ${{ secrets.YOUTUBE_TOKEN }}
      run: |
        echo "üîç Setting up YouTube credentials..."
        
        # Debug: Check if secrets are available
        CRED_SET="${{ secrets.YOUTUBE_CREDENTIALS != '' }}"
        TOKEN_SET="${{ secrets.YOUTUBE_TOKEN != '' }}"
        
        echo "üìã Secret availability check:"
        echo "   - YOUTUBE_CREDENTIALS: $CRED_SET"
        echo "   - YOUTUBE_TOKEN: $TOKEN_SET"
        
        # Method 1: Try environment variable approach
        if [ -n "$YOUTUBE_CREDENTIALS" ] && [ "$YOUTUBE_CREDENTIALS" != "" ]; then
          echo "‚úÖ YOUTUBE_CREDENTIALS found via environment variable"
          echo "$YOUTUBE_CREDENTIALS" > credentials.json
        # Method 2: Try direct secret substitution
        elif [ "${{ secrets.YOUTUBE_CREDENTIALS }}" != "" ]; then
          echo "‚úÖ YOUTUBE_CREDENTIALS found via direct secret"
          cat > credentials.json << 'EOL'
        ${{ secrets.YOUTUBE_CREDENTIALS }}
        EOL
        else
          echo "‚ùå YOUTUBE_CREDENTIALS not available through either method"
        fi
        
        # Validate credentials file
        if [ -f credentials.json ]; then
          FILE_SIZE=$(wc -c < credentials.json)
          echo "‚úÖ credentials.json created (size: $FILE_SIZE bytes)"
          
          if [ $FILE_SIZE -gt 10 ]; then
            # Validate JSON format (without showing content)
            if jq empty credentials.json > /dev/null 2>&1; then
              echo "‚úÖ credentials.json is valid JSON"
              
              # Check for required Google API fields
              if jq -e '.type, .project_id, .client_id' credentials.json > /dev/null 2>&1; then
                echo "‚úÖ credentials.json contains required Google API fields"
                echo "YOUTUBE_CREDENTIALS_VALID=true" >> $GITHUB_ENV
              else
                echo "‚ùå credentials.json missing required Google API fields"
                echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
              fi
            else
              echo "‚ùå credentials.json is not valid JSON"
              echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
              echo "üìÑ First 100 characters of file:"
              head -c 100 credentials.json
            fi
          else
            echo "‚ùå credentials.json file is too small (likely empty)"
            echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
          fi
        else
          echo "‚ùå credentials.json file was not created"
          echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
        fi
        
        # Handle YouTube token restoration
        if [ -n "$YOUTUBE_TOKEN" ] && [ "$YOUTUBE_TOKEN" != "" ]; then
          echo "$YOUTUBE_TOKEN" | base64 -d > token.pickle 2>/dev/null
          if [ -f token.pickle ] && [ -s token.pickle ]; then
            echo "‚úÖ YouTube token restored successfully"
          else
            echo "‚ö†Ô∏è YouTube token restoration failed"
          fi
        elif [ "${{ secrets.YOUTUBE_TOKEN }}" != "" ]; then
          echo "${{ secrets.YOUTUBE_TOKEN }}" | base64 -d > token.pickle 2>/dev/null
          if [ -f token.pickle ] && [ -s token.pickle ]; then
            echo "‚úÖ YouTube token restored via direct secret"
          else
            echo "‚ö†Ô∏è YouTube token restoration failed via direct secret"
          fi
        else
          echo "‚ÑπÔ∏è No YouTube token found (normal for first run)"
        fi
        
        # Final status
        if [ "$YOUTUBE_CREDENTIALS_VALID" = "true" ]; then
          echo "‚úÖ YouTube credentials setup completed successfully"
        else
          echo "‚ö†Ô∏è YouTube credentials setup failed - upload will be disabled"
          echo "üí° Troubleshooting tips:"
          echo "   1. Verify YOUTUBE_CREDENTIALS secret exists in repository settings"
          echo "   2. Ensure the secret contains valid JSON from Google Cloud Console"
          echo "   3. Check that the JSON includes all required fields (type, project_id, client_id, etc.)"
        fi

    - name: Set upload status
      run: |
        echo "üîß Determining upload status..."
        ENABLE_UPLOAD_VAR="${{ vars.ENABLE_UPLOAD || 'true' }}"
        echo "üìã Configuration check:"
        echo "   - YOUTUBE_CREDENTIALS_VALID: ${{ env.YOUTUBE_CREDENTIALS_VALID }}"
        echo "   - ENABLE_UPLOAD variable: $ENABLE_UPLOAD_VAR"
        
        if [ "${{ env.YOUTUBE_CREDENTIALS_VALID }}" = "true" ] && [ "$ENABLE_UPLOAD_VAR" = "true" ]; then
          echo "‚úÖ Upload will be enabled"
          echo "UPLOAD_TO_YOUTUBE=true" >> $GITHUB_ENV
        else
          echo "‚ö†Ô∏è Upload will be disabled"
          if [ "${{ env.YOUTUBE_CREDENTIALS_VALID }}" != "true" ]; then
            echo "   Reason: Invalid credentials"
          fi
          if [ "$ENABLE_UPLOAD_VAR" != "true" ]; then
            echo "   Reason: Upload disabled in settings"
          fi
          echo "UPLOAD_TO_YOUTUBE=false" >> $GITHUB_ENV
        fi

    - name: Create environment file
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        VIDEO_PRIVACY: ${{ vars.VIDEO_PRIVACY || 'public' }}
        VIDEO_CATEGORY_ID: ${{ vars.VIDEO_CATEGORY_ID || '28' }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        # Validate required secrets
        if [ -z "$OPENAI_API_KEY" ]; then
          echo "‚ùå OPENAI_API_KEY is not set in repository secrets"
          exit 1
        fi
        
        # Create .env file
        cat > .env << EOF
        OPENAI_API_KEY=$OPENAI_API_KEY
        VIDEO_PRIVACY=$VIDEO_PRIVACY
        VIDEO_CATEGORY_ID=$VIDEO_CATEGORY_ID
        UPLOAD_TO_YOUTUBE=${{ env.UPLOAD_TO_YOUTUBE }}
        EOF
        
        # Add optional variables
        if [ -n "$DISCORD_WEBHOOK_URL" ]; then
          echo "DISCORD_WEBHOOK_URL=$DISCORD_WEBHOOK_URL" >> .env
          echo "DISCORD_NOTIFICATIONS_ENABLED=true" >> $GITHUB_ENV
        else
          echo "DISCORD_NOTIFICATIONS_ENABLED=false" >> $GITHUB_ENV
        fi
        
        if [ -n "${{ github.event.inputs.topic_override }}" ]; then
          echo "TOPIC_OVERRIDE=${{ github.event.inputs.topic_override }}" >> .env
        fi
        
        if [ -n "${{ github.event.inputs.category_override }}" ]; then
          echo "CATEGORY_OVERRIDE=${{ github.event.inputs.category_override }}" >> .env
        fi
        
        echo "‚úÖ Environment file created with $(wc -l < .env) variables"
        echo "üìã Final upload status: ${{ env.UPLOAD_TO_YOUTUBE }}"
        
        # Show sanitized version
        sed 's/\(.*API_KEY=\).*/\1[HIDDEN]/' .env | sed 's/\(.*WEBHOOK_URL=\).*/\1[HIDDEN]/'

    - name: Run YouTube automation
      id: automation
      env:
        # Explicitly pass all environment variables to the Python process
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        VIDEO_PRIVACY: ${{ vars.VIDEO_PRIVACY || 'public' }}
        VIDEO_CATEGORY_ID: ${{ vars.VIDEO_CATEGORY_ID || '28' }}
        UPLOAD_TO_YOUTUBE: ${{ env.UPLOAD_TO_YOUTUBE }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        TOPIC_OVERRIDE: ${{ github.event.inputs.topic_override }}
        CATEGORY_OVERRIDE: ${{ github.event.inputs.category_override }}
        PYTHONUNBUFFERED: "1"  # Ensure real-time output
        PYTHONPATH: ${{ github.workspace }}:${{ github.workspace }}/utils
      run: |
        echo "üöÄ Starting YouTube automation..."
        echo "üìÖ Timestamp: $(date)"
        echo "üêç Python version: $(python --version)"
        echo "üìÅ Working directory: $(pwd)"
        echo "üìÇ Directory contents:"
        ls -la
        
        # Show final upload status
        echo "üìã Final configuration:"
        echo "   - YouTube credentials valid: ${{ env.YOUTUBE_CREDENTIALS_VALID }}"
        echo "   - Upload enabled: ${{ env.UPLOAD_TO_YOUTUBE }}"
        echo "   - Video privacy: $VIDEO_PRIVACY"
        
        # Run the automation with proper error handling
        set -o pipefail
        python main.py 2>&1 | tee automation.log
        EXIT_CODE=${PIPESTATUS[0]}
        
        echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
        
        if [ $EXIT_CODE -ne 0 ]; then
          echo "‚ùå Automation failed with exit code $EXIT_CODE"
          echo "üìã Last 20 lines of output:"
          tail -20 automation.log || echo "Could not read log file"
          exit $EXIT_CODE
        fi
        
        echo "‚úÖ Automation completed successfully"

    - name: Save updated YouTube token
      if: always() && env.YOUTUBE_CREDENTIALS_VALID == 'true'
      id: save_token
      run: |
        if [ -f token.pickle ]; then
          base64 -w 0 token.pickle > token_updated.txt
          echo "token_content=$(cat token_updated.txt)" >> $GITHUB_OUTPUT
          echo "‚úÖ Updated token prepared for storage"
          
          # Optionally, you could save this back to secrets using GitHub API
          # This would require a personal access token with repo permissions
          echo "üí° Consider updating your YOUTUBE_TOKEN secret with the new token"
          echo "üìÑ New token (base64): $(head -c 50 token_updated.txt)..."
        else
          echo "‚ÑπÔ∏è No token.pickle file found to save"
        fi

    - name: Upload artifacts on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: automation-failure-logs-${{ github.run_number }}
        path: |
          automation.log
          output/
          logs/
          *.json
          *.txt
          *.env
        retention-days: 7

    - name: Upload successful artifacts
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: automation-success-${{ github.run_number }}
        path: |
          output/
          logs/
          automation.log
        retention-days: 3

    - name: Extract video information
      if: success()
      id: video_info
      run: |
        # Extract video information from logs
        VIDEO_TITLE=$(grep -E "^‚úÖ Topic:" automation.log | head -1 | cut -d' ' -f3- 2>/dev/null || echo "Unknown")
        VIDEO_ID=$(grep "Video uploaded with ID:" automation.log | tail -1 | awk '{print $NF}' 2>/dev/null || echo "")
        VIDEO_CATEGORY=$(grep -E "^‚úÖ Category:" automation.log | head -1 | cut -d' ' -f3- 2>/dev/null || echo "Unknown")
        
        # Clean up extracted values
        VIDEO_TITLE=$(echo "$VIDEO_TITLE" | sed 's/[^a-zA-Z0-9 .,!?-]//g' | head -c 100)
        VIDEO_ID=$(echo "$VIDEO_ID" | grep -E '^[a-zA-Z0-9_-]{11}$' || echo "")
        
        echo "video_title=$VIDEO_TITLE" >> $GITHUB_OUTPUT
        echo "video_id=$VIDEO_ID" >> $GITHUB_OUTPUT
        echo "video_category=$VIDEO_CATEGORY" >> $GITHUB_OUTPUT
        
        echo "üì∫ Extracted video info:"
        echo "   Title: $VIDEO_TITLE"
        echo "   ID: $VIDEO_ID"
        echo "   Category: $VIDEO_CATEGORY"

    - name: Send success notification
      if: success() && env.DISCORD_NOTIFICATIONS_ENABLED == 'true'
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        VIDEO_TITLE="${{ steps.video_info.outputs.video_title }}"
        VIDEO_ID="${{ steps.video_info.outputs.video_id }}"
        VIDEO_CATEGORY="${{ steps.video_info.outputs.video_category }}"
        UPLOAD_STATUS="${{ env.UPLOAD_TO_YOUTUBE == 'true' && 'Uploaded' || 'Generated (Upload Disabled)' }}"
        
        if [ -n "$VIDEO_ID" ] && [ "$VIDEO_ID" != "" ]; then
          # Create JSON payload for successful upload
          PAYLOAD=$(cat << EOF
        {
          "embeds": [{
            "title": "‚úÖ YouTube Video Published Successfully!",
            "description": "**Title:** ${VIDEO_TITLE}\n**Category:** ${VIDEO_CATEGORY}\n**Video ID:** ${VIDEO_ID}\n**URL:** https://www.youtube.com/watch?v=${VIDEO_ID}\n**Shorts:** https://youtube.com/shorts/${VIDEO_ID}",
            "color": 5763719,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
            "footer": {
              "text": "YouTube Automation ‚Ä¢ Run #${{ github.run_number }}"
            }
          }]
        }
        EOF
          )
        else
          # Create JSON payload for generation without upload
          PAYLOAD=$(cat << EOF
        {
          "embeds": [{
            "title": "‚úÖ YouTube Video Generated Successfully!",
            "description": "**Title:** ${VIDEO_TITLE}\n**Category:** ${VIDEO_CATEGORY}\n**Status:** ${UPLOAD_STATUS}\n**Note:** Video was generated but not uploaded (check credentials setup)",
            "color": 16776960,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
            "footer": {
              "text": "YouTube Automation ‚Ä¢ Run #${{ github.run_number }}"
            }
          }]
        }
        EOF
          )
        fi
        
        curl -H "Content-Type: application/json" \
             -X POST \
             -d "$PAYLOAD" \
             "$DISCORD_WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send Discord notification"

    - name: Send failure notification
      if: failure() && env.DISCORD_NOTIFICATIONS_ENABLED == 'true'
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        # Extract error information
        ERROR_MSG=$(tail -10 automation.log 2>/dev/null | tr '\n' ' ' | sed 's/"/\\"/g' | head -c 400 || echo "Unknown error - check logs")
        STEP_NAME=$(echo "${{ github.workflow }}" | head -c 50)
        
        # Create failure notification
        PAYLOAD=$(cat << EOF
        {
          "embeds": [{
            "title": "‚ùå YouTube Automation Failed",
            "description": "**Error:** ${ERROR_MSG}\n**Run:** #${{ github.run_number }}\n**Workflow:** ${STEP_NAME}\n**Branch:** ${{ github.ref_name }}\n**Commit:** ${{ github.sha }}",
            "color": 15158332,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
            "footer": {
              "text": "Check the Actions tab for detailed logs"
            }
          }]
        }
        EOF
        )
        
        curl -H "Content-Type: application/json" \
             -X POST \
             -d "$PAYLOAD" \
             "$DISCORD_WEBHOOK_URL" || echo "‚ö†Ô∏è Failed to send Discord failure notification"

  cleanup:
    runs-on: ubuntu-latest
    needs: create-and-upload-video
    if: always()
    
    steps:
    - name: Cleanup old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          try {
            console.log('üßπ Starting artifact cleanup...');
            
            // Get all artifacts for this repository
            const { data: artifacts } = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            console.log(`Found ${artifacts.artifacts.length} total artifacts`);
            
            // Filter and sort artifacts by creation date (newest first)
            const oldArtifacts = artifacts.artifacts
              .filter(artifact => artifact.name.includes('automation-'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
              .slice(10); // Keep only the 10 most recent
            
            console.log(`Found ${oldArtifacts.length} old artifacts to delete`);
            
            // Delete old artifacts
            for (const artifact of oldArtifacts) {
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                });
                console.log(`‚úÖ Deleted artifact: ${artifact.name} (${artifact.created_at})`);
              } catch (error) {
                console.log(`‚ö†Ô∏è Failed to delete artifact ${artifact.name}: ${error.message}`);
              }
            }
            
            console.log('‚úÖ Artifact cleanup completed');
            
          } catch (error) {
            console.log(`‚ùå Cleanup failed: ${error.message}`);
            // Don't fail the workflow if cleanup fails
          }

    - name: Cleanup summary
      run: |
        echo "üßπ Artifact cleanup job completed"
        echo "üìä Workflow summary:"
        echo "   - Run number: ${{ github.run_number }}"
        echo "   - Triggered by: ${{ github.event_name }}"
        echo "   - Branch: ${{ github.ref_name }}"
        echo "   - Commit: ${{ github.sha }}"