name: YouTube Automation

on:
  schedule:
    - cron: '0 9 * * *'  # Daily at 9:00 AM UTC
  workflow_dispatch:
    inputs:
      topic_override:
        description: 'Override today''s topic (optional)'
        required: false
        type: string
      category_override:
        description: 'Override category (optional)'
        required: false
        type: string

jobs:
  create-and-upload-video:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg espeak espeak-data libespeak1 libespeak-dev
        sudo apt-get install -y python3-dev python3-pip python3-venv
        sudo apt-get install -y libffi-dev libssl-dev libxml2-dev libxslt-dev
        sudo apt-get install -y build-essential libasound2-dev portaudio19-dev
        sudo apt-get install -y jq
        sudo apt-get install -y libavcodec-dev libavformat-dev libavdevice-dev
        sudo apt-get install -y libavfilter-dev libswscale-dev libswresample-dev
        sudo apt-get install -y imagemagick
        # Modify ImageMagick policy to allow text operations
        if [ -f /etc/ImageMagick-6/policy.xml ]; then
          sudo sed -i 's/<policy domain="path" rights="none" pattern="@*" \/>/<policy domain="path" rights="read|write" pattern="@*" \/>/' /etc/ImageMagick-6/policy.xml
        elif [ -f /etc/ImageMagick/policy.xml ]; then
          sudo sed -i 's/<policy domain="path" rights="none" pattern="@*" \/>/<policy domain="path" rights="read|write" pattern="@*" \/>/' /etc/ImageMagick/policy.xml
        else
          echo "âš ï¸ ImageMagick policy file not found"
        fi
        ffmpeg -version
        convert -version
        echo "âœ… System dependencies installed"

    - name: Verify system dependencies
      run: |
        echo "ðŸ” Verifying system dependencies..."
        ffmpeg -version || { echo "âŒ FFmpeg not installed correctly"; exit 1; }
        convert -version || { echo "âŒ ImageMagick not installed correctly"; exit 1; }
        if [ -f /etc/ImageMagick-6/policy.xml ]; then
          grep 'path.*@.*read|write' /etc/ImageMagick-6/policy.xml && echo "âœ… ImageMagick policy updated"
        elif [ -f /etc/ImageMagick/policy.xml ]; then
          grep 'path.*@.*read|write' /etc/ImageMagick/policy.xml && echo "âœ… ImageMagick policy updated"
        else
          echo "âš ï¸ ImageMagick policy file not found"
        fi
        echo "âœ… FFmpeg and ImageMagick verified"

    - name: Check disk space
      run: |
        echo "ðŸ” Checking available disk space..."
        df -h
        echo "âœ… Disk space check completed"

    - name: Install Python dependencies
      run: |
        echo "ðŸ“¦ Installing Python dependencies..."
        python -m pip cache purge
        python -m pip install --upgrade pip==24.2 setuptools==70.3.0 wheel==0.43.0
        pip install --no-cache-dir -r requirements.txt
        pip install --no-cache-dir --force-reinstall moviepy==1.0.2 openai==1.40.6 numpy==1.26.4 python-dotenv==1.0.1
        pip list  # Log installed packages for debugging
        echo "âœ… All dependencies installed successfully"

    - name: Check for proxies references
      run: |
        echo "ðŸ” Checking for 'proxies' in Python files..."
        git grep -i "proxies" *.py utils/*.py || echo "No 'proxies' references found"
        echo "âœ… Proxies check completed"

    - name: Log script contents for debugging
      run: |
        echo "ðŸ” Logging contents of main.py and utils/scripting.py..."
        echo "ðŸ“„ main.py:"
        cat main.py || echo "âŒ main.py not found"
        echo "ðŸ“„ utils/scripting.py:"
        cat utils/scripting.py || echo "âŒ utils/scripting.py not found"
        echo "âœ… Script contents logged"

    - name: Fix namespace packages and verify installations
      run: |
        echo "ðŸ”§ Fixing namespace packages and performing comprehensive verification..."
        python -c "
        import sys
        import subprocess
        import importlib
        import os
        
        print('ðŸ Python version:', sys.version)
        print('ðŸ” Python executable:', sys.executable)
        print('ðŸ“ Python path:')
        for path in sys.path:
            print(f'   {path}')
        
        # Fix Google namespace package issue
        print('\nðŸ”§ Fixing Google namespace packages...')
        
        # Find site-packages directories safely
        site_packages_dirs = []
        for path in sys.path:
            if path and 'site-packages' in path and os.path.exists(path):
                site_packages_dirs.append(path)
        
        print(f'Found site-packages directories: {site_packages_dirs}')
        
        # Look for Google packages in site-packages directories
        google_packages = []
        for site_dir in site_packages_dirs:
            try:
                packages = [pkg for pkg in os.listdir(site_dir) 
                           if pkg.startswith('google') and os.path.isdir(os.path.join(site_dir, pkg))]
                google_packages.extend(packages)
            except (OSError, PermissionError) as e:
                print(f'Could not list {site_dir}: {e}')
        
        print(f'Found Google packages: {list(set(google_packages))}')
        
        # Remove any conflicting __pycache__ directories
        import shutil
        for site_packages in site_packages_dirs:
            google_dir = os.path.join(site_packages, 'google')
            if os.path.exists(google_dir):
                pycache_dir = os.path.join(google_dir, '__pycache__')
                if os.path.exists(pycache_dir):
                    try:
                        shutil.rmtree(pycache_dir)
                        print(f'âœ… Removed {pycache_dir}')
                    except Exception as e:
                        print(f'âš ï¸ Could not remove {pycache_dir}: {e}')
        
        # Test packages with enhanced error handling
        test_results = []
        
        def test_import_advanced(module_name, import_statement, display_name=None):
            if display_name is None:
                display_name = module_name
                
            try:
                # Clear any cached imports
                if module_name in sys.modules:
                    del sys.modules[module_name]
                
                # Clear related modules for complex packages
                if module_name == 'moviepy':
                    modules_to_clear = [mod for mod in sys.modules.keys() if 'moviepy' in mod]
                    for mod in modules_to_clear:
                        del sys.modules[mod]
                elif module_name.startswith('google'):
                    modules_to_clear = [mod for mod in sys.modules.keys() if mod.startswith('google')]
                    for mod in modules_to_clear:
                        del sys.modules[mod]
                elif module_name == 'openai':
                    modules_to_clear = [mod for mod in sys.modules.keys() if 'openai' in mod]
                    for mod in modules_to_clear:
                        del sys.modules[mod]
                
                # Execute the import statement
                exec(import_statement)
                print(f'âœ… {display_name}: Import successful')
                test_results.append((display_name, True, 'OK'))
                return True
            except Exception as e:
                print(f'âŒ {display_name}: {str(e)}')
                test_results.append((display_name, False, str(e)))
                return False
        
        # Test all critical packages with proper import statements
        print('\nðŸ” Testing imports with advanced verification...')
        test_import_advanced('numpy', 'import numpy')
        test_import_advanced('PIL', 'from PIL import Image')
        test_import_advanced('openai', 'import openai')
        test_import_advanced('gtts', 'from gtts import gTTS')
        test_import_advanced('pydub', 'from pydub import AudioSegment')
        test_import_advanced('requests', 'import requests')
        
        # Special handling for moviepy with multiple fallback strategies
        print('\nðŸŽ¬ Testing MoviePy with fallback strategies...')
        moviepy_success = False
        
        # Strategy 1: Direct import
        try:
            import moviepy
            import moviepy.editor as mpe
            print(f'âœ… MoviePy Strategy 1 (direct): Success')
            moviepy_success = True
        except Exception as e:
            print(f'âŒ MoviePy Strategy 1 failed: {e}')
            
            # Strategy 2: Reinstall and retry
            try:
                print('ðŸ”§ MoviePy Strategy 2: Reinstalling...')
                subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'moviepy'], 
                             capture_output=True, check=False)
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 
                              '--no-deps', 'moviepy==1.0.3'], 
                             capture_output=True, check=True)
                
                # Clear module cache
                for mod in list(sys.modules.keys()):
                    if 'moviepy' in mod:
                        del sys.modules[mod]
                
                import moviepy.editor as mpe
                print('âœ… MoviePy Strategy 2 (reinstall): Success')
                moviepy_success = True
            except Exception as e2:
                print(f'âŒ MoviePy Strategy 2 failed: {e2}')
                
                # Strategy 3: Install different version
                try:
                    print('ðŸ”§ MoviePy Strategy 3: Different version...')
                    subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 
                                  '--force-reinstall', 'moviepy==1.0.2'], 
                                 capture_output=True, check=True)
                    
                    # Clear module cache again
                    for mod in list(sys.modules.keys()):
                        if 'moviepy' in mod:
                            del sys.modules[mod]
                    
                    import moviepy.editor as mpe
                    print('âœ… MoviePy Strategy 3 (v1.0.2): Success')
                    moviepy_success = True
                except Exception as e3:
                    print(f'âŒ MoviePy Strategy 3 failed: {e3}')
        
        test_results.append(('MoviePy', moviepy_success, 'OK' if moviepy_success else 'Failed'))
        
        # Special handling for google.auth with namespace fixes
        print('\nðŸ” Testing Google Auth with namespace fixes...')
        google_success = False
        
        # Strategy 1: Direct import
        try:
            import google.auth
            import google_auth_oauthlib
            import googleapiclient.discovery
            print('âœ… Google Auth Strategy 1 (direct): Success')
            google_success = True
        except Exception as e:
            print(f'âŒ Google Auth Strategy 1 failed: {e}')
            
            # Strategy 2: Clear namespace and reinstall
            try:
                print('ðŸ”§ Google Auth Strategy 2: Namespace fix...')
                
                # Clear all google-related modules
                for mod in list(sys.modules.keys()):
                    if mod.startswith('google'):
                        del sys.modules[mod]
                
                # Reinstall google packages in correct order
                subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 
                              'google-auth', 'google-auth-oauthlib', 'google-api-python-client'], 
                             capture_output=True, check=False)
                
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 
                              'google-auth'], capture_output=True, check=True)
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 
                              'google-auth-oauthlib'], capture_output=True, check=True)
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 
                              'google-api-python-client'], capture_output=True, check=True)
                
                import google.auth
                print('âœ… Google Auth Strategy 2 (namespace fix): Success')
                google_success = True
            except Exception as e2:
                print(f'âŒ Google Auth Strategy 2 failed: {e2}')
        
        test_results.append(('Google Auth', google_success, 'OK' if google_success else 'Failed'))
        
        # Special handling for OpenAI
        print('\nðŸ” Testing OpenAI with fallback strategies...')
        openai_success = False
        
        # Strategy 1: Direct import
        try:
            import openai
            print('âœ… OpenAI Strategy 1 (direct): Success')
            openai_success = True
        except Exception as e:
            print(f'âŒ OpenAI Strategy 1 failed: {e}')
            
            # Strategy 2: Reinstall and retry
            try:
                print('ðŸ”§ OpenAI Strategy 2: Reinstalling...')
                subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'openai'], 
                             capture_output=True, check=False)
                subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 
                              'openai==1.40.6'], capture_output=True, check=True)
                
                # Clear module cache
                for mod in list(sys.modules.keys()):
                    if 'openai' in mod:
                        del sys.modules[mod]
                
                import openai
                print('âœ… OpenAI Strategy 2 (reinstall): Success')
                openai_success = True
            except Exception as e2:
                print(f'âŒ OpenAI Strategy 2 failed: {e2}')
        
        test_results.append(('OpenAI', openai_success, 'OK' if openai_success else 'Failed'))
        
        # Summary
        failed = [name for name, success, _ in test_results if not success]
        if failed:
            print(f'\nâŒ Failed imports: {failed}')
            print('\nâš ï¸ Some packages failed to import. The script will attempt to continue...')
            print('\nDiagnostic information:')
            print('Available packages:')
            result = subprocess.run([sys.executable, '-m', 'pip', 'list'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if any(pkg in line.lower() for pkg in ['moviepy', 'google', 'openai']):
                        print(f'   {line}')
        else:
            print('\nâœ… All critical packages verified successfully!')
        "

    - name: Clear Python module cache
      run: |
        echo "ðŸ§¹ Clearing Python module cache..."
        find . -name "*.pyc" -delete
        find . -name "__pycache__" -type d -exec rm -rf {} +
        echo "âœ… Module cache cleared"

    - name: Create output directories
      run: |
        mkdir -p output
        mkdir -p logs
        echo "âœ… Output directories created"

    - name: Set up YouTube credentials
      env:
        YOUTUBE_CREDENTIALS: ${{ secrets.YOUTUBE_CREDENTIALS }}
        YOUTUBE_TOKEN: ${{ secrets.YOUTUBE_TOKEN }}
      run: |
        echo "ðŸ” Setting up YouTube credentials..."
        
        CRED_SET="${{ secrets.YOUTUBE_CREDENTIALS != '' }}"
        TOKEN_SET="${{ secrets.YOUTUBE_TOKEN != '' }}"
        
        echo "ðŸ“‹ Secret availability check:"
        echo "   - YOUTUBE_CREDENTIALS: $CRED_SET"
        echo "   - YOUTUBE_TOKEN: $TOKEN_SET"
        
        if [ -n "$YOUTUBE_CREDENTIALS" ] && [ "$YOUTUBE_CREDENTIALS" != "" ]; then
          echo "âœ… YOUTUBE_CREDENTIALS found via environment variable"
          echo "$YOUTUBE_CREDENTIALS" > credentials.json
        elif [ "${{ secrets.YOUTUBE_CREDENTIALS }}" != "" ]; then
          echo "âœ… YOUTUBE_CREDENTIALS found via direct secret"
          cat > credentials.json << 'EOL'
        ${{ secrets.YOUTUBE_CREDENTIALS }}
        EOL
        else
          echo "âŒ YOUTUBE_CREDENTIALS not available through either method"
        fi
        
        if [ -f credentials.json ]; then
          FILE_SIZE=$(wc -c < credentials.json)
          echo "âœ… credentials.json created (size: $FILE_SIZE bytes)"
          
          if [ $FILE_SIZE -gt 10 ]; then
            if jq empty credentials.json > /dev/null 2>&1; then
              echo "âœ… credentials.json is valid JSON"
              
              if jq -e '.installed.type, .installed.project_id, .installed.client_id' credentials.json > /dev/null 2>&1; then
                echo "âœ… credentials.json contains required Google API fields (installed app format)"
                echo "YOUTUBE_CREDENTIALS_VALID=true" >> $GITHUB_ENV
              elif jq -e '.type, .project_id, .client_id' credentials.json > /dev/null 2>&1; then
                echo "âœ… credentials.json contains required Google API fields (service account format)"
                echo "YOUTUBE_CREDENTIALS_VALID=true" >> $GITHUB_ENV
              else
                echo "âŒ credentials.json missing required Google API fields"
                echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
              fi
            else
              echo "âŒ credentials.json is not valid JSON"
              echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
            fi
          else
            echo "âŒ credentials.json file is too small (likely empty)"
            echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
          fi
        else
          echo "âŒ credentials.json file was not created"
          echo "YOUTUBE_CREDENTIALS_VALID=false" >> $GITHUB_ENV
        fi
        
        if [ -n "$YOUTUBE_TOKEN" ] && [ "$YOUTUBE_TOKEN" != "" ]; then
          echo "$YOUTUBE_TOKEN" | base64 -d > token.pickle 2>/dev/null
          if [ -f token.pickle ] && [ -s token.pickle ]; then
            echo "âœ… YouTube token restored successfully"
          else
            echo "âš ï¸ YouTube token restoration failed"
          fi
        elif [ "${{ secrets.YOUTUBE_TOKEN }}" != "" ]; then
          echo "${{ secrets.YOUTUBE_TOKEN }}" | base64 -d > token.pickle 2>/dev/null
          if [ -f token.pickle ] && [ -s token.pickle ]; then
            echo "âœ… YouTube token restored via direct secret"
          else
            echo "âš ï¸ YouTube token restoration failed via direct secret"
          fi
        else
          echo "â„¹ï¸ No YouTube token found (normal for first run)"
        fi
        
        echo "âœ… YouTube credentials setup completed"

    - name: Set upload status
      run: |
        echo "ðŸ”§ Determining upload status..."
        ENABLE_UPLOAD_VAR="${{ vars.ENABLE_UPLOAD || 'true' }}"
        echo "ðŸ“‹ Configuration check:"
        echo "   - YOUTUBE_CREDENTIALS_VALID: ${{ env.YOUTUBE_CREDENTIALS_VALID }}"
        echo "   - ENABLE_UPLOAD variable: $ENABLE_UPLOAD_VAR"
        
        if [ "${{ env.YOUTUBE_CREDENTIALS_VALID }}" = "true" ] && [ "$ENABLE_UPLOAD_VAR" = "true" ]; then
          echo "âœ… Upload will be enabled"
          echo "UPLOAD_TO_YOUTUBE=true" >> $GITHUB_ENV
        else
          echo "âš ï¸ Upload will be disabled"
          echo "UPLOAD_TO_YOUTUBE=false" >> $GITHUB_ENV
        fi

    - name: Create environment file
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        VIDEO_PRIVACY: ${{ vars.VIDEO_PRIVACY || 'public' }}
        VIDEO_CATEGORY_ID: ${{ vars.VIDEO_CATEGORY_ID || '28' }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        if [ -z "$OPENAI_API_KEY" ]; then
          echo "âŒ OPENAI_API_KEY is not set in repository secrets"
          exit 1
        fi
        
        cat > .env << EOF
        OPENAI_API_KEY=$OPENAI_API_KEY
        VIDEO_PRIVACY=$VIDEO_PRIVACY
        VIDEO_CATEGORY_ID=$VIDEO_CATEGORY_ID
        UPLOAD_TO_YOUTUBE=${{ env.UPLOAD_TO_YOUTUBE }}
        EOF
        
        if [ -n "$DISCORD_WEBHOOK_URL" ]; then
          echo "DISCORD_WEBHOOK_URL=$DISCORD_WEBHOOK_URL" >> .env
          echo "DISCORD_NOTIFICATIONS_ENABLED=true" >> $GITHUB_ENV
        else
          echo "DISCORD_NOTIFICATIONS_ENABLED=false" >> $GITHUB_ENV
        fi
        
        if [ -n "${{ github.event.inputs.topic_override }}" ]; then
          echo "TOPIC_OVERRIDE=${{ github.event.inputs.topic_override }}" >> .env
        fi
        
        if [ -n "${{ github.event.inputs.category_override }}" ]; then
          echo "CATEGORY_OVERRIDE=${{ github.event.inputs.category_override }}" >> .env
        fi
        
        echo "âœ… Environment file created"

    - name: Run YouTube automation
      id: automation
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        VIDEO_PRIVACY: ${{ vars.VIDEO_PRIVACY || 'public' }}
        VIDEO_CATEGORY_ID: ${{ vars.VIDEO_CATEGORY_ID || '28' }}
        UPLOAD_TO_YOUTUBE: ${{ env.UPLOAD_TO_YOUTUBE }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        TOPIC_OVERRIDE: ${{ github.event.inputs.topic_override }}
        CATEGORY_OVERRIDE: ${{ github.event.inputs.category_override }}
        PYTHONUNBUFFERED: "1"
        PYTHONPATH: ${{ github.workspace }}:${{ github.workspace }}/utils
        PYTHONDONTWRITEBYTECODE: "1"
        PYTHONIOENCODING: "utf-8"
        HTTP_PROXY: ""
        HTTPS_PROXY: ""
        NO_PROXY: "*"
      run: |
        echo "ðŸš€ Starting YouTube automation..."
        echo "ðŸ“… Timestamp: $(date)"
        echo "ðŸ Python version: $(python --version)"
        echo "ðŸ“ Working directory: $(pwd)"
        echo "ðŸ“‹ Final configuration:"
        echo "   - YouTube credentials valid: ${{ env.YOUTUBE_CREDENTIALS_VALID }}"
        echo "   - Upload enabled: ${{ env.UPLOAD_TO_YOUTUBE }}"
        echo "   - Video privacy: $VIDEO_PRIVACY"
        echo "ðŸ” Environment variables (sensitive values masked):"
        python -c "
        import os
        for key, value in sorted(os.environ.items()):
            if key in ['OPENAI_API_KEY', 'YOUTUBE_CREDENTIALS', 'YOUTUBE_TOKEN', 'DISCORD_WEBHOOK_URL']:
                print(f'   - {key}: ***')
            else:
                print(f'   - {key}: {value}')
        "
        
        # Final check and potential fix before running main script
        python -c "
        import sys
        import subprocess
        
        print('ðŸ”§ Final pre-execution checks...')
        
        # Clear and fix MoviePy
        for mod in list(sys.modules.keys()):
            if 'moviepy' in mod:
                del sys.modules[mod]
        
        try:
            import moviepy.editor
            print('âœ… MoviePy ready')
        except Exception as e:
            print(f'ðŸ”§ Final MoviePy fix attempt... Error: {e}')
            subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'moviepy'], check=False)
            subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 'moviepy==1.0.2'], check=False)
            try:
                import moviepy.editor
                print('âœ… MoviePy installed successfully')
            except Exception as e2:
                print(f'âŒ MoviePy installation failed: {e2}')
        
        # Clear and fix Google Auth
        for mod in list(sys.modules.keys()):
            if mod.startswith('google'):
                del sys.modules[mod]
        
        try:
            import google.auth
            print('âœ… Google Auth ready')
        except Exception as e:
            print(f'ðŸ”§ Final Google Auth fix attempt... Error: {e}')
            subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'google-auth', 'google-auth-oauthlib', 'google-api-python-client'], check=False)
            subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 'google-auth', 'google-auth-oauthlib', 'google-api-python-client'], check=False)
            try:
                import google.auth
                print('âœ… Google Auth installed successfully')
            except Exception as e2:
                print(f'âŒ Google Auth installation failed: {e2}')
        
        # Clear and fix OpenAI
        for mod in list(sys.modules.keys()):
            if 'openai' in mod:
                del sys.modules[mod]
        
        try:
            import openai
            print('âœ… OpenAI ready')
        except Exception as e:
            print(f'ðŸ”§ Final OpenAI fix attempt... Error: {e}')
            subprocess.run([sys.executable, '-m', 'pip', 'uninstall', '-y', 'openai'], check=False)
            subprocess.run([sys.executable, '-m', 'pip', 'install', '--no-cache-dir', 'openai==1.40.6'], check=False)
            try:
                import openai
                print('âœ… OpenAI installed successfully')
            except Exception as e2:
                print(f'âŒ OpenAI installation failed: {e2}')
        
        print('ðŸš€ Ready to execute main script')
        "
        
        set -o pipefail
        python main.py 2>&1 | tee automation.log
        EXIT_CODE=$PIPESTATUS[0]
        
        echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
        
        if [ $EXIT_CODE -ne 0 ]; then
          echo "âŒ Automation failed with exit code $EXIT_CODE"
          echo "ðŸ“‹ Last 20 lines of output:"
          tail -20 automation.log || echo "Could not read log file"
          exit $EXIT_CODE
        fi
        
        echo "âœ… Automation completed successfully"

    - name: Debug environment on failure
      if: failure()
      run: |
        echo "ðŸ” Debugging environment..."
        pip list
        python -m site
        echo "âœ… Environment debug info collected"

    - name: Save updated YouTube token
      if: always() && env.YOUTUBE_CREDENTIALS_VALID == 'true'
      id: save_token
      run: |
        if [ -f token.pickle ]; then
          base64 -w 0 token.pickle > token_updated.txt
          echo "token_content=$(cat token_updated.txt)" >> $GITHUB_OUTPUT
          echo "âœ… Updated token prepared for storage"
        else
          echo "â„¹ï¸ No token.pickle file found to save"
        fi

    - name: Upload artifacts on failure or partial success
      if: failure() || steps.automation.outputs.exit_code == '2'
      uses: actions/upload-artifact@v4
      with:
        name: automation-failure-logs-${{ github.run_number }}
        path: |
          automation.log
          output/
          logs/
          *.json
          *.txt
          *.env
        retention-days: 7

    - name: Upload successful artifacts
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: automation-success-${{ github.run_number }}
        path: |
          output/
          logs/
          automation.log
        retention-days: 3

    - name: Extract video information
      if: success()
      id: video_info
      run: |
        VIDEO_TITLE=$(grep -E "^âœ… Topic:" automation.log | head -1 | cut -d' ' -f3- 2>/dev/null || echo "Unknown")
        VIDEO_ID=$(grep "Video uploaded with ID:" automation.log | tail -1 | awk '{print $NF}' 2>/dev/null || echo "")
        VIDEO_CATEGORY=$(grep -E "^âœ… Category:" automation.log | head -1 | cut -d' ' -f3- 2>/dev/null || echo "Unknown")
        
        VIDEO_TITLE=$(echo "$VIDEO_TITLE" | sed 's/[^a-zA-Z0-9 .,!?-]//g' | head -c 100)
        VIDEO_ID=$(echo "$VIDEO_ID" | grep -E '^[a-zA-Z0-9_-]{11}$' || echo "")
        
        echo "video_title=$VIDEO_TITLE" >> $GITHUB_OUTPUT
        echo "video_id=$VIDEO_ID" >> $GITHUB_OUTPUT
        echo "video_category=$VIDEO_CATEGORY" >> $GITHUB_OUTPUT

    - name: Send success notification
      if: success() && env.DISCORD_NOTIFICATIONS_ENABLED == 'true'
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        VIDEO_TITLE="${{ steps.video_info.outputs.video_title }}"
        VIDEO_ID="${{ steps.video_info.outputs.video_id }}"
        VIDEO_CATEGORY="${{ steps.video_info.outputs.video_category }}"
        UPLOAD_STATUS="${{ env.UPLOAD_TO_YOUTUBE == 'true' && 'Uploaded' || 'Generated (Upload Disabled)' }}"
        
        if [ -n "$VIDEO_ID" ] && [ "$VIDEO_ID" != "" ]; then
          PAYLOAD=$(cat << EOF
        {
          "embeds": [{
            "title": "âœ… YouTube Video Published Successfully!",
            "description": "**Title:** ${VIDEO_TITLE}\n**Category:** ${VIDEO_CATEGORY}\n**Video ID:** ${VIDEO_ID}\n**URL:** https://www.youtube.com/watch?v=${VIDEO_ID}",
            "color": 5763719,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
            "footer": {
              "text": "YouTube Automation â€¢ Run #${{ github.run_number }}"
            }
          }]
        }
        EOF
          )
        else
          PAYLOAD=$(cat << EOF
        {
          "embeds": [{
            "title": "âœ… YouTube Video Generated Successfully!",
            "description": "**Title:** ${VIDEO_TITLE}\n**Category:** ${VIDEO_CATEGORY}\n**Status:** ${UPLOAD_STATUS}",
            "color": 16776960,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
            "footer": {
              "text": "YouTube Automation â€¢ Run #${{ github.run_number }}"
            }
          }]
        }
        EOF
          )
        fi
        
        curl -H "Content-Type: application/json" \
             -X POST \
             -d "$PAYLOAD" \
             "$DISCORD_WEBHOOK_URL" || echo "âš ï¸ Failed to send Discord notification"

    - name: Send failure notification
      if: failure() && env.DISCORD_NOTIFICATIONS_ENABLED == 'true'
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        ERROR_MSG=$(tail -10 automation.log 2>/dev/null | tr '\n' ' ' | sed 's/"/\\"/g' | head -c 400 || echo "Unknown error - check logs")
        STEP_NAME=$(echo "${{ github.workflow }}" | head -c 50)
        
        PAYLOAD=$(cat << EOF
        {
          "embeds": [{
            "title": "âŒ YouTube Automation Failed",
            "description": "**Error:** ${ERROR_MSG}\n**Run:** #${{ github.run_number }}\n**Workflow:** ${STEP_NAME}",
            "color": 15158332,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
            "footer": {
              "text": "Check the Actions tab for detailed logs"
            }
          }]
        }
        EOF
        )
        
        curl -H "Content-Type: application/json" \
             -X POST \
             -d "$PAYLOAD" \
             "$DISCORD_WEBHOOK_URL" || echo "âš ï¸ failed to send Discord failure notification"

  cleanup:
    runs-on: ubuntu-latest
    needs: create-and-upload-video
    if: always()
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Cleanup old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          try {
            console.log('ðŸ§¹ Starting artifact cleanup...');
            
            const { data: artifacts } = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            console.log(`Found ${artifacts.artifacts.length} total artifacts`);
            
            const oldArtifacts = artifacts.artifacts
              .filter(artifact => artifact.name.includes('automation-'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
              .slice(10); # Keep only the 10 most recent automation artifacts
            
            console.log(`Found ${oldArtifacts.length} old artifacts to delete`);
            
            let deletedCount = 0;
            let failedCount = 0;
            
            for (const artifact of oldArtifacts) {
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                });
                
                console.log(`âœ… Deleted artifact: ${artifact.name} (ID: ${artifact.id})`);
                deletedCount++;
                
                # Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
                
              } catch (deleteError) {
                console.error(`âŒ Failed to delete artifact ${artifact.name}: ${deleteError.message}`);
                failedCount++;
              }
            }
            
            console.log(`âœ… Cleanup completed: ${deletedCount} deleted, ${failedCount} failed`);
            
            if (deletedCount > 0) {
              console.log('ðŸŽ‰ Successfully cleaned up old automation artifacts');
            }
            
          } catch (error) {
            console.error('âŒ Artifact cleanup failed:', error.message);
            console.log('âš ï¸ Continuing despite cleanup failure...');
          }

    - name: Cleanup old workflow runs
      uses: actions/github-script@v7
      with:
        script: |
          try {
            console.log('ðŸ§¹ Starting workflow run cleanup...');
            
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
              status: 'completed'
            });
            
            console.log(`Found ${runs.workflow_runs.length} completed workflow runs`);
            
            # Keep only the 20 most recent completed runs
            const oldRuns = runs.workflow_runs
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
              .slice(20);
            
            console.log(`Found ${oldRuns.length} old workflow runs to delete`);
            
            let deletedRunCount = 0;
            let failedRunCount = 0;
            
            for (const run of oldRuns) {
              try {
                # Only delete runs older than 30 days
                const runDate = new Date(run.created_at);
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                
                if (runDate < thirtyDaysAgo) {
                  await github.rest.actions.deleteWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id
                  });
                  
                  console.log(`âœ… Deleted workflow run: #${run.run_number} (ID: ${run.id})`);
                  deletedRunCount++;
                  
                  # Add a small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 200));
                }
              } catch (deleteError) {
                console.error(`âŒ Failed to delete workflow run #${run.run_number}: ${deleteError.message}`);
                failedRunCount++;
              }
            }
            
            console.log(`âœ… Workflow cleanup completed: ${deletedRunCount} deleted, ${failedRunCount} failed`);
            
          } catch (error) {
            console.error('âŒ Workflow run cleanup failed:', error.message);
            console.log('âš ï¸ Continuing despite workflow cleanup failure...');
          }

    - name: Report cleanup summary
      uses: actions/github-script@v7
      with:
        script: |
          console.log('ðŸ“Š Cleanup Summary:');
          console.log('==================');
          console.log('âœ… Artifact cleanup: Completed');
          console.log('âœ… Workflow run cleanup: Completed');
          console.log('ðŸŽ¯ Repository maintenance finished successfully');
          
          # Optional: Create a summary for the workflow
          const summary = `
          ## ðŸ§¹ Cleanup Summary
          
          - **Artifacts**: Cleaned up old automation artifacts (keeping 10 most recent)
          - **Workflow Runs**: Cleaned up runs older than 30 days (keeping 20 most recent)
          - **Status**: Maintenance completed successfully
          
          > This cleanup job helps maintain repository storage and performance.
          `;
          
          await core.summary
            .addRaw(summary)
            .write();